#!/usr/bin/env python3

"""
This program is one of the coolest examples of a day to day task.
It basically checks for logs within a file and creates two reports:
    1. Report of info, errors generated per user.
    2. Report of count of unique errors within the log.

Program Arguments:
    1. The log file.

Functions:
    1. =line_to_groups(line):
        The function basically converts a line from a file into three values:
            a. Log Type: INFO or ERROR
            b. Log Message: The info or error message generated by the system in the logfile.
            c. UserID: The user id of the user that caused the event.

    2. create_error_stats(log_message, log_type):
        The function expects the log message and the type of the log.
        It then generates a list consisting of multiple tuples with values in the below format:
            ('Error Message', 'Count of occurences of the error')

    3. create_user_stats(log_type, user):
        The function expects the log type and user ID.
        It then generates a list consisting of multiple tuples with values in the below format:
            (UserID, [Count of info messages, Count of error messages])
        Every user ID is mapped to the count of info/error messages it generates.

    4. write_to_csv(error_list, user_list):
        The function expects the lists of tuples generated by the create_error_stats and create_user_stats functions.
        It creates two files:
            a. error_message.csv        -->     Mapping error messages to count of occurences
            b. user_statistics.csv      -->     Mapping User IDs to count of info and error messages generated by the user.

Errors/Exceptions:
    1. FileNotFoundError: If a particular log file path given by the user is not found on the system.
    2. IndexError: If the user does not provide the log file path.

Usage:
    Windows:    python ticky.py <logfile_name>
    Unix:       ./ticky.py <log_file_path>
"""

import re, sys, operator, csv

error_dict = {}
per_user = {}

def line_to_groups(line):
    pattern = r"ticky: (INFO|ERROR) ([\w' ]*\[[#\d]*\]|[\w' ]*) \(([\w.]*)\)"
    result = re.search(pattern,line)
    return result.group(1),result.group(2),result.group(3)

def create_error_stats(log_message, log_type):
    if log_type.upper() == 'ERROR':
        error_dict[log_message] = error_dict.get(log_message, 0) + 1
    error_details_list = [('Error', 'Count')] + sorted(error_dict.items(), key = operator.itemgetter(1), reverse=True)
    return error_details_list

def create_user_stats(log_type,user):
    if user in per_user.keys():
        if log_type.upper() == 'INFO':
            per_user[user][0] += 1
        elif log_type.upper() == 'ERROR':
            per_user[user][1] += 1
    else:
        if log_type.upper() == 'INFO':
            per_user[user] = [1,0]
        elif log_type.upper() == 'ERROR':
            per_user[user] = [0,1]

    sorted_user_list = [('Username', ['INFO', 'ERROR'])] + sorted(per_user.items())
    return sorted_user_list

def write_to_csv(sorted_user_list, sorted_error_list):
    with open('error_message.csv','w') as error_stats_csv:
        writer = csv.writer(error_stats_csv)
        writer.writerows(sorted_error_list)

    with open('user_statistics.csv', 'w') as user_stats_csv:
        writer = csv.writer(user_stats_csv)
        for item in sorted_user_list:
            username = item[0]
            info_count = item[1][0]
            error_count = item[1][1]
            writer.writerow([username,info_count,error_count])


if __name__ == '__main__':
    try:
        fh = open(sys.argv[1])
        fh.close()
    except IndexError:
        print("\n\nPlease enter a log file path as well!\n\n")
        sys.exit(1)
    except FileNotFoundError:
        print("\n\nPlease enter the correct log file path!\n\n")
        sys.exit(1)

    with open(sys.argv[1],'r') as f:
        for line in f.readlines():
            log_type,log_message,user = line_to_groups(line)
            user_list = create_user_stats(log_type,user)
            error_list = create_error_stats(log_message, log_type)

    write_to_csv(user_list,error_list)
